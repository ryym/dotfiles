#!/usr/bin/env bash

# Display the help information with auto pagination and colors.
# Usage: "help bat", "help git status"

shopt -s expand_aliases
source "$DOTPATH/dotfiles/shell/aliases"

if [ $# -eq 0 ]; then
    echo "Usage: help <command> [args...]"
    return 1
fi

cmd="$1"

# Resolve alias.
cmd_type=$(command -v "$cmd" 2>/dev/null)
case "$cmd_type" in
    'alias '*)
        # If the given command for help is an alias, `command -v` will print a value
        # like "alias g=git" or "alias ls='ls -F'". This sed tries to extract the actual
        # command by stripping the parts of "alias ls=" and "'" in the last.
        cmd=$(echo "$cmd_type" | sed "s/^alias [^=]*='*//; s/'*$//")
        ;;
esac

shift

# - $cmd may contain multiple commands if it is resolved from an alias (e.g. "bundle exec").
# - $@ may contain sub commands (e.g. "status" of "git").
# Build a cmds array from $cmd and $@ while excluding options which starts with "-".
# If $cmd="bundle exec" and $@="rails server", $cmds=("bundle", "exec", "rails", "server").
cmds=()
words=($cmd)
for w in "${words[@]}"; do
    [[ $w =~ ^- ]] && break
    cmds+=("$w")
done
for w in "$@"; do
    [[ $w =~ ^- ]] && break
    cmds+=("$w")
done

output=$("${cmds[@]}" --help 2>&1)
nlines=$(echo "$output" | wc -l)
title="ðŸ“– ${cmds[@]} --help ($nlines lines)"

echo "$title

$output" | bat -l help --plain
