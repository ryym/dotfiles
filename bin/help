#!/usr/bin/env bash

# Display the help information with auto pagination and colors.
# Usage: "help bat", "help git status", or "fzf --help | help"

shopt -s expand_aliases
source "$DOTPATH/dotfiles/shell/aliases"

# Stdin is redirected or piped.
if [ ! -t 0 ]; then
    bat -l help --plain
    exit
fi

if [ $# -eq 0 ]; then
    echo "Usage: help <command> [args...]"
    exit 1
fi

cmd="$1"

# Resolve alias.
cmd_type=$(command -v "$cmd" 2>/dev/null)
case "$cmd_type" in
    'alias '*)
        # If the given command for help is an alias, `command -v` will print a value
        # like "alias g=git" or "alias ls='ls -F'". This sed tries to extract the actual
        # command by stripping the parts of "alias ls=" and "'" in the last.
        cmd=$(echo "$cmd_type" | sed "s/^alias [^=]*='*//; s/'*$//")
        ;;
esac

shift

# - $cmd may contain multiple commands if it is resolved from an alias (e.g. "bundle exec").
# - $@ may contain sub commands (e.g. "status" of "git").
# Build a cmds array from $cmd and $@ while excluding options which starts with "-".
# If $cmd="bundle exec" and $@="rails server", $cmds=("bundle", "exec", "rails", "server").
cmds=()
words=($cmd)
for w in "${words[@]}"; do
    [[ $w =~ ^- ]] && break
    cmds+=("$w")
done
for w in "$@"; do
    [[ $w =~ ^- ]] && break
    cmds+=("$w")
done

case "${cmds[0]}" in
    npm | aws)
        cmds=("${cmds[0]}" 'help' ${cmds[@]:1})
        ;;
    *)
        cmds=("${cmds[@]}" '--help')
esac

output=$("${cmds[@]}" 2>&1)
if [ $? -eq 0 ]; then
    nlines=$(echo "$output" | wc -l | sed 's/^[[:space:]]*//')
    title="ðŸ“– ${cmds[@]} ($nlines lines)"
    (echo "$title"; echo "$output") | bat -l help --plain "$@"
else
    echo "$output"
fi
