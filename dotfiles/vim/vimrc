"""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vimrc
"""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Initializing {{{1

" Skip initialization if '+eval' feature is disabled {{{
" Note: (see: :help no-eval-feature)
"   In '-eval' environment, the argument of 'if' (including '| endif')
"   is ignored. So all lines after 'if' are ignored too. But
"   backslashes of line-continuation are still recognized and
"   cause errors when 'compatible' option is set. So
"   setting 'cpoptions' to enable line-continuation before
"   'if' statement makes sure all lines get ignored without error.
" }}}
set cpoptions-=C | if 0 | endif

" Default properties
let g:is_windows = has('win32') || has('win64')
let g:is_mac     = has('mac')   || has('macunix') || has('gui_macvim')
let g:is_gui     = has('gui_running')
let $MYVIMDIR    = expand( g:is_windows ? '~/vimfiles' : '~/.vim' )
let $VIMLOCAL    = expand($MYVIMDIR . '/local')

" Reset all autocmd defined in vimrc.
" TODO: create ex command to define vimrc autocmd.
augroup vimrc
  autocmd!
augroup END

if has('vim_starting')
  autocmd vimrc VimEnter * call <SID>display_startup_time()

  let s:startuptime = reltime()
  function! s:display_startup_time()
    echomsg 'Startup time:' reltimestr( reltime(s:startuptime) )
    unlet s:startuptime
  endfunction

  " Change the cursor to vertical bar in normal mode on the terminal.
  " (https://qiita.com/Linda_pp/items/9e0c94eb82b18071db34)
  let &t_SI .= "\e[6 q"
  let &t_EI .= "\e[2 q"
endif



" Colorscheme {{{1

augroup vimrc
  autocmd ColorScheme hybrid highlight LineNr ctermfg=58 guifg=#676b41
  autocmd ColorScheme hybrid highlight Comment guifg=#707880 gui=none,italic
  autocmd ColorScheme hybrid highlight VertSplit ctermfg=60 guifg=#5f5b84
augroup END

if has('vim_starting')
  set t_Co =256
  if &t_Co < 256
    colorscheme desert
  else
    colorscheme smyck256
  endif
endif



" Commands and functions {{{1

" SID {{{2

function! s:SID()
  return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
endfunction


" Reload and Edit .vimrc {{{2

command! Rv  source $MYVIMRC | if g:is_gui | source $MYGVIMRC | endif
command! Ev  edit   $MYVIMRC
if g:is_gui
 command! Evg edit $MYGVIMRC
endif

command! Evp edit $MYVIMDIR/plugins.vim


" Set indent easily {{{2

command! -nargs=* IndentBy call <SID>set_indent(<f-args>)
command! ShortIndent  IndentBy 2 1
command! MediumIndent IndentBy 4 1

function! s:set_indent(n_space, expand_tab)
  let &l:shiftwidth  = a:n_space
  let &l:tabstop     = a:n_space
  let &l:softtabstop = a:n_space
  let &l:expandtab   = a:expand_tab
endfunction


" QuickfixDo {{{2

command! -nargs=+ QfDo call <SID>quickfix_do(<q-args>)

" Execute the specified command for each buffer in the quickfix list.
" From: http://stackoverflow.com/questions/4792561/how-to-do-search-replace-with-ack-in-vim/4793316#4793316
function! s:quickfix_do(command)
    let buffer_numbers = {}
    for fixlist_entry in getqflist()
      let buffer_numbers[ fixlist_entry['bufnr'] ] = 1
    endfor
    let buffer_number_list = keys(buffer_numbers)

    let current_bufnr = bufnr('%')
    for bufnr in buffer_number_list
      if bufexists( str2nr(bufnr) )
        execute 'keepalt buffer' bufnr
        execute a:command
      endif
    endfor
    execute 'keepalt buffer' current_bufnr
endfunction


" Restore last cursor position {{{2

command! RestoreCursorPosition call <SID>restore_cursor_position()

function! s:restore_cursor_position()
  if line("'\"") > 1 && line("'\"") <= line("$")
    execute 'normal! g`"'
  endif
endfunction


" Capture command outputs {{{2

command! -nargs=+ -complete=command
  \ Capture call <SID>capture_output_of(<q-args>)
cnoreabbrev cap Capture

" Capture command outputs.
" If any errors occurred, capture nothing.
function! s:capture_output_of(commands)
  redir => output
  try
    silent execute a:commands
  catch
    echoerr v:exception | return
  finally
    redir END
  endtry

  new
  file `=printf('Output of: [ %s ]', a:commands)`
  setlocal buftype   =nofile
  setlocal bufhidden =delete
  call setline(1, split(output, '\n'))
endfunction


" Grep by external programs {{{2

" Helper functions {{{3

function! s:make_grepprg_obj(program, command, grepprg)
  return {
    \ 'program' : a:program,
    \ 'command' : a:command,
    \ 'grepprg' : a:grepprg,
    \ 'executable' : a:program !=# 'vim' ? executable(a:program) : 1
    \ }
endfunction

function! s:select_executable_programs()
  return filter(copy(s:grepprgs.order), "s:grepprgs.prgs[v:val].executable")
endfunction

function! s:select_first_executable_grepprg()
  let executables = s:select_executable_programs()
  return s:grepprgs.prgs[ executables[0] ]
endfunction

function! s:display_available_greps()
  let greps = s:select_executable_programs()
  let current = s:grepprgs.current.program
  return join( map(greps, "v:val ==# current ? '['.v:val.']' : v:val "), ' ' )
endfunction

" Run grep by the specified program.
function! s:grep_by(is_append_mode, bang, program, args)
  let save_grepprg = &grepprg

  let config = s:grepprgs.prgs[a:program]
  let &grepprg = config.grepprg

  let grep = 'grep' . (a:is_append_mode ? 'add' : '') . a:bang
  silent execute grep a:args '| cwindow | redraw!'
  echo len(getqflist()) "matches."
  let &grepprg = save_grepprg
endfunction

" Change the current grep program.
function! s:change_grep_program(program) abort
  if ! has_key(s:grepprgs.prgs, a:program)
    echoerr a:program 'is unknown as a grep command.'
    return
  endif

  let config = s:grepprgs.prgs[a:program]
  if ! config.executable
    echoerr a:program 'can not be executed.'
    return
  endif

  let s:grepprgs.current = config
  echo 'Grep is set to:' a:program
endfunction

" Various grep commands {{{3

" The dictionary which stores some information about grep commands.
let s:grepprgs = {
  \ 'order' : ['git', 'ag', 'pt', 'vim'],
  \ 'prgs' : {
  \   'git' : s:make_grepprg_obj('git', 'GitGrep', 'git grep -n'),
  \   'ag'  : s:make_grepprg_obj('ag', 'AgGrep', 'ag --nocolor --nogroup'),
  \   'pt'  : s:make_grepprg_obj('pt', 'PtGrep', 'pt --nocolor --nogroup'),
  \   'vim' : s:make_grepprg_obj('vim', 'VimGrep', 'internal')
  \  }
  \ }
" Set the first executable command to the current grep program.
let s:grepprgs.current = s:select_first_executable_grepprg()

" Define the custom grep commands.
for [s:program, s:config] in items(s:grepprgs.prgs)
  " Grep command
  execute printf(
    \ "command! -bang -nargs=+ -complete=file %s call <SID>grep_by(0, '<bang>', '%s', <q-args>)",
    \ s:config.command, s:program)

  " GrepAdd command
  execute printf(
    \ "command! -bang -nargs=+ -complete=file %sAdd call <SID>grep_by(1, '<bang>' '%s', <q-args>)",
    \ s:config.command, s:program)
endfor
unlet s:program s:config

command! -nargs=1 ChangeGrep call <SID>change_grep_program(<q-args>)
command! ShowGreps echo 'Available greps: ' <SID>display_available_greps()


" Load rc-bundles {{{2

" 'rc-bundle' meeans the bundles that used mainly in .vimrc itself.
" All rc-bundles must be in '$MYVIMDIR/rcbundle/'.
command! -nargs=1 RcBundle
  \ if has('vim_starting') |
  \   call <SID>load_rc_bundle(<f-args>) |
  \ endif

function! s:load_rc_bundle(bundle_name)
  let bundle_rtp = expand('$MYVIMDIR/rcbundle/' . a:bundle_name)
  execute 'set runtimepath+=' . bundle_rtp
  execute 'runtime plugin/' . a:bundle_name
  execute 'helptags' bundle_rtp . '/doc'
  if isdirectory(bundle_rtp . '/after')
    execute 'set runtimepath+=' . bundle_rtp . '/after'
  endif
endfunction


" Take diff of windows {{{2

" Take diff of opened windows or close diff mode if it opened.
command! Windiff call <SID>toggle_win_diff(&diff)

function! s:toggle_win_diff(is_opened)
  if a:is_opened
    diffoff!
  else
    windo diffthis
  endif
endfunction

" Print current line syntaxes {{{2

" Print syntax names at the current cursor position.
command! SyntaxNames :echo <SID>get_current_syntax_names()

function! s:get_current_syntax_names()
  return map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endfunction


" Others {{{2

" Print each path of &runtimepath.
command! Rtp echo substitute(&runtimepath, ',', '\n', 'g')

" Remove trailing whitespaces without cursor moving.
command! Rtw :%s/\v\s+$// | let v:hlsearch = 0 | normal! ``



" Basic options {{{1

language C
set helplang =en,ja

set encoding      =utf-8
set fileencoding  =utf-8
set fileencodings =utf-8,cp932

if exists('&ambiwidth')
  set ambiwidth =double
endif

filetype plugin indent on
syntax on

" Default tab/space settings.
set tabstop     =4
set shiftwidth  =4
set softtabstop =4
set expandtab
set autoindent
set smartindent

" Search settings.
set hlsearch
set incsearch
set ignorecase
set smartcase

" Avoid highlighting the last search pattern at reloading vimrc.
nohlsearch

" Disable file backups.
set nobackup
set nowritebackup
set noswapfile

if has('persistent_undo')
  if ! isdirectory($VIMLOCAL . '/undo')
    call mkdir($VIMLOCAL . '/undo')
  endif
  set undofile
  set undodir =$VIMLOCAL/undo
endif

" Briefly jump to the matching bracket.
set showmatch
set matchtime =2
set matchpairs& matchpairs+=<:>

" Folds settings.
set foldmethod =marker
set foldcolumn =3

set cursorline
set number
set relativenumber
set hidden
set ruler
set showcmd
set showmode
set autoread
set nostartofline
set title
set wildmenu
set list
set listchars   =tab:>\ "
set backspace   =indent,eol,start
set linespace   =1
set mouse       =a
set clipboard   =unnamed
set keywordprg  =:help
set scrolloff   =3
set textwidth   =0
set history     =50
set laststatus  =2
set cmdheight   =2
set completeopt =longest,menuone
set whichwrap   =b,s,<,>,[,]
set statusline  =%f%m%r%h%w\ -\ [%{(&fenc!=''?&fenc:&enc)}\ %{&ff}\ %Y]\ [%Llines\]\ (%04l,%04v)
set formatoptions =croql
set fileignorecase
set timeoutlen  =1200
set ttimeoutlen =10 " To eliminate delays on <Esc> in terminal.
set gdefault

" Indent counts of leading backslash for line continuations in vim script.
let g:vim_indent_cont = 2



" Default events {{{1

augroup vimrc
  autocmd WinEnter * checktime
  autocmd BufReadPost * RestoreCursorPosition
augroup END



" Filetype settings {{{1

" Options for each file type {{{2

" Helper function {{{

function! s:delegate_filetypes(filetypes)
  for [name_pattern, type] in items(a:filetypes)
    execute 'autocmd BufNewFile,BufRead' name_pattern
      \ 'setlocal filetype='.type
  endfor
endfunction

function! s:reflesh_commentstring_in_html()
  let syntaxes = join(s:get_current_syntax_names(), ' ')
  if syntaxes =~ 'html'
    setlocal commentstring=<!--%s-->
  elseif syntaxes =~ 'javaScript'
    setlocal commentstring=//%s
  elseif syntaxes =~ 'css'
    setlocal commentstring=/*%s*/
  else
  endif
endfunction

" }}}

augroup vimrc
  " Groovy local settings
  autocmd FileType groovy setlocal cindent cinoptions& cinoptions+=j1

  " Show relative line numbers in help files.
  autocmd FileType help setlocal relativenumber

  " Set commentstring correctly for JS and CSS in HTML and Vue files.
  autocmd CursorMoved *.html,*.vue call <SID>reflesh_commentstring_in_html()

  " Configure filetypes which have to be assigned manually.
  call s:delegate_filetypes({
    \ '*.gradle'     : 'groovy',
    \ '*.es6'        : 'javascript',
    \ '.babelrc'     : 'json',
    \ '.pryrc'       : 'ruby',
    \ 'Guardfile'    : 'ruby',
    \ 'Vagrantfile'  : 'ruby',
    \ 'Berksfile'    : 'ruby',
    \ 'Dockerfile.*' : 'Dockerfile'
    \ })
augroup END


" Indent settings {{{2

augroup vimrc
  autocmd FileType javascript ShortIndent
  autocmd FileType typescript ShortIndent
  autocmd FileType coffee     ShortIndent
  autocmd FileType css        ShortIndent
  autocmd FileType scss       ShortIndent
  autocmd FileType sass       ShortIndent
  autocmd FileType haml       ShortIndent
  autocmd FileType yaml       ShortIndent
  autocmd FileType ruby       ShortIndent
  autocmd FileType vim        ShortIndent
  autocmd FileType vimspec    ShortIndent
  autocmd FileType scala      ShortIndent
  autocmd FileType sql        ShortIndent
  autocmd FileType json       ShortIndent
  autocmd FileType html       ShortIndent
  autocmd FileType xhtml      ShortIndent
  autocmd FileType eruby      ShortIndent
  autocmd FileType jsp        ShortIndent
  autocmd FileType vue        ShortIndent
  autocmd FileType c          MediumIndent
  autocmd FileType cs         MediumIndent
  autocmd FileType vb         MediumIndent
  autocmd FileType java       MediumIndent
  autocmd FileType groovy     MediumIndent
  autocmd FileType xml        MediumIndent
  autocmd FileType sh         MediumIndent
  autocmd FileType markdown   MediumIndent
  autocmd FileType go         IndentBy 4 0
  autocmd FileType text       IndentBy 4 0
  autocmd FileType help       IndentBy 8 0
augroup END


" Apply file type settings {{{2
if ! has('vim_starting')
  " Apply file type settings to the current buffer when vimrc is reloaded.
  doautocmd vimrc FileType
endif



" Key mappings {{{1

" Set up {{{2

" Use custom mapping commands.
RcBundle mapping.vim
call mapping#set_sid(s:SID())
let g:mapping_named_key_format = '\[%s]'

" Change the mapping of text object {rhs} to {lhs}.
function! s:map_text_object(lhs, rhs)
  execute 'Map ox' 'i' . a:lhs  'i' . a:rhs
  execute 'Map ox' 'a' . a:lhs  'a' . a:rhs
endfunction

" Define 'mapleader' before all mappings usiing <Leader>.
let mapleader = "-"
Map nv - <Nop>

" Disable these keys to use as the main leader keys.
Map n m       <Nop>
Map n q       <Nop>
Map n <Space> <Nop>


" Numbers {{{2

" Invert numbers by <Space> (to type 6 - 9 by left hand).
for s:n in range(1, 9)
  execute 'Map nvo <Space>' . s:n . ' ' . (10 - s:n)
endfor
unlet s:n


" Insert mode {{{2

Map i <C-j> <Down>
Map i <C-k> <Up>
Map i <C-h> <Left>
Map i <C-l> <Right>
Map i <C-a> <Esc><S-i>
Map i <C-e> <End>
Remap i <C-CR> <End><CR>
Remap i <S-CR> <C-o>O
Remap i <S-Tab> <Tab><Tab>

" Break undo sequence after these deletions in Insert mode.
Map i <C-w> <C-g>u<C-w>
Map i <C-u> <C-g>u<C-u>

" Break a line without inserting the comment leader.
Map i <C-]> <C-o>:set formatoptions-=ro<CR><CR><C-o>:set formatoptions+=ro<CR>

Map i <C-w> <C-r>=<SID>start_file_completion()<CR>

" Improve file path completion {{{3
" Vim has a file name completion but it is done from the
" current directory, not a directory of a current file.
" But I want to do it from the current file's directory.
" To achieve this, we need to change the current directory
" temporaliry while completion.
let s:file_completion_curdir = ''
function! s:start_file_completion()
  let cwd = getcwd()
  let file_dir = expand("%:p:h")

  if empty(s:file_completion_curdir) && cwd != file_dir
    augroup vimrc_file_completion
      autocmd InsertLeave * call <SID>restore_current_dir()
    augroup END
    let s:file_completion_curdir = cwd
  endif

  call execute('cd ' . file_dir)
  return "\<C-x>\<C-f>"
endfunction

function! s:restore_current_dir()
  call execute('cd ' . s:file_completion_curdir)
  let s:file_completion_curdir = ''
  augroup vimrc_file_completion
    autocmd!
  augroup END
endfunction


" Visual mode {{{2

" Reselect visual block after indent.
Map v < <gv
Map v > >gv


" Command-line mode {{{2

" Like emacs.
Map c <C-a> <Home>
Map c <C-b> <Left>
Map c <C-e> <End>
Map c <C-f> <Right>
Map c <C-n> <Down>
Map c <C-p> <Up>

" Paste current path by '%%'.
Map c (expr) %% getcmdtype() == ':' ? expand('%:h') : '%%'


" Basic operation in normal mode {{{2

Map n mm m
Map n _  `
Map n <C-h>     :us:vert help
Map n <Leader>h :us:help
Map n <Space>w  ::update
Map n <Space>W  ::update!
Map n <Space>q  ::quit
Map n <Space>Q  ::quit!
Map n <C-j> <C-e>gj
Map n <C-k> <C-y>gk
Map n Y y$
Map n Q q
Map n <Leader>d ::pwd
Map n zp zMzv
Map n <C-w>\\ ::vsplit
Map n <C-w>- ::split

" Break lines and Insert spaces in normal mode.
Map n <C-CR>          o<Esc>
Map n <S-CR>          O<Esc>
Map n <S-Space>       i<Space><Esc>
Map n <Leader><Space> a<Space><Esc>

" Remove trailing whitespaces.
Map n (silent) <Leader>c ::Rtw

" In US keyboard, typing ':' is so hard..
Map nv ; :
Map nv : ;


" Fix the direction of the ';', ',', 'n', 'N' {{{2

" Make the ';' key always move to the right.
" Make the ',' key always move to the left.
Map nvo (expr) f <SID>map_repeat_keys_and_move_to_occurrence(1, 'f')
Map nvo (expr) F <SID>map_repeat_keys_and_move_to_occurrence(0, 'F')
Map nvo (expr) t <SID>map_repeat_keys_and_move_to_occurrence(1, 't')
Map nvo (expr) T <SID>map_repeat_keys_and_move_to_occurrence(0, 'T')

" Make the 'n' key always move forward.
" Make the 'N' key always move backward.
Map nvo (expr) n <SID>search_pattern_to_fixed_direction('n', 'N')
Map nvo (expr) N <SID>search_pattern_to_fixed_direction('N', 'n')

function! s:map_repeat_keys_and_move_to_occurrence(direct_to_right, command)
  if a:direct_to_right
    Map nvo : ;
    Map nvo , ,
  else
    Map nvo : ,
    Map nvo , ;
  endif
  return a:command
endfunction

function! s:search_pattern_to_fixed_direction(normal_key, reverse_key)
  return v:searchforward ? a:normal_key : a:reverse_key
endfunction


" Text objects {{{2

call s:map_text_object('d', '"')
call s:map_text_object('s', "'")
call s:map_text_object('m', ')')
call s:map_text_object('n', '}')
call s:map_text_object('y', '>')


" Toggle options {{{2

MapNamedKey co toggle

" Toggle search highlight.
Map n (silent) \[toggle]h ::let v:hlsearch = ! v:hlsearch

" Toggle scrollbinds of each window.
Map n \[toggle]S ::windo setlocal scrollbind! scrollbind?

" Toggle indent width.
Map n \[toggle]i :f:<SID>toggle_indent_width()

function! s:toggle_indent_width()
  if &tabstop <= 2
    call s:set_indent(4, &expandtab)
    echo 'Medium indent (4)'
  else
    call s:set_indent(2, &expandtab)
    echo 'Short indent (2)'
  endif
endfunction

" Toggle colorschemes.
Map n \[toggle]c :f:<SID>toggle_colorschemes()

let s:togglable_colors = ['smyck256', 'hybrid']
function! s:toggle_colorschemes()
  let current = index(s:togglable_colors, g:colors_name)
  let next = (current + 1) % len(s:togglable_colors)
  execute 'colorscheme' s:togglable_colors[next]
endfunction

" Toggle comment continuation at line breaking.
Map n \[toggle]* :f:<SID>toggle_comment_continuation()

function! s:toggle_comment_continuation()
  let will_continue = ( match(&formatoptions, '\v[ro]') != -1 )
  if will_continue
    set formatoptions -=ro
    echo 'Do not continue comment lines'
  else
    set formatoptions +=ro
    echo 'Continue comment lines'
  endif
endfunction


" Disallow some delete operations to change clipboard {{{2

" The 'd' and 'c' keys can change clipboard.
for s:lkey in ['s', 'x']
  let s:ukey = toupper(s:lkey)
  execute 'Map nv' s:lkey '"_' . s:lkey
  execute 'Map nv' s:ukey '"_' . s:ukey
endfor

" Leave the default operation
" ('ms' is used by 'easymotion').
Map nv mx x
Map nv mX X

" The 'md' and 'mc' commands delete texts without copy.
Map nv md "_d
Map nv mD "_D
Map nv mc "_c
Map nv mC "_C


" Paste texts smartly {{{2

Map i (silent) <C-v> <C-o>:set paste<CR><C-r>*<C-o>:set nopaste<CR>
Map c <C-v> <C-r>*


" Grep by external programs {{{2

" Toggle the current grep program.
let s:grep_mappings = {
  \ 'a' : 'ag',
  \ 'p' : 'pt',
  \ 'v' : 'vim'
  \ }
for [s:key, s:program] in items(s:grep_mappings)
  execute printf("Map n \\[grep]%s ::ChangeGrep %s", s:key, s:program)
endfor
unlet s:grep_mappings s:key s:program

" Start grep using the current program.
function! s:grep_by_current_program(is_append_mode)
  let command = s:grepprgs.current.command
  return ':' . command . (a:is_append_mode ? 'Add' : '') . '! '
endfunction

MapNamedKey <Space>s grep
Map n (expr) \[grep]s <SID>grep_by_current_program(0)
Map n (expr) \[grep]+ <SID>grep_by_current_program(1)
Map n \[grep]l ::ShowGreps


" Quickfix {{{2

Map n qo  ::cwindow
Map n qc  ::cclose
Map n qj  ::cnext
Map n qk  ::cprevious
Map n ql  ::cnfile
Map n qh  ::cpfile
Map n qgg ::cfirst
Map n qG  ::clast
Map n qn  ::cnewer
Map n qp  ::colder


" Buffers {{{2

MapNamedKey <Space>b buffer
Map n \[buffer]a ::buffer #
Map n \[buffer]d ::bdelete
Map n \[buffer]l ::ls
Map n \[buffer]s :us:ls<CR>:buffer
Map n \[buffer]j ::execute 'buffer' v:count1


" Tabs {{{2

" Use 't' as the prefix of tab motions.
MapNamedKey t tab
Map n \[tab]n ::tabnew
Map n \[tab]h gT
Map n \[tab]l gt
" TODO: mappings for tab motions



" Plugins {{{1

source $MYVIMDIR/plugins.vim

runtime macros/matchit.vim



" Local settings {{{1

if filereadable($VIMLOCAL . '/vimrc')
  source $VIMLOCAL/vimrc
  command! Evl edit $VIMLOCAL/vimrc
endif

" }}}

" vim: expandtab softtabstop=2 shiftwidth=2 foldmethod=marker
