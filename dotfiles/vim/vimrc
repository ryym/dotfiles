"""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vimrc
"""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Skip initialization if '+eval' feature is disabled {{{
" Note: (see: :help no-eval-feature)
"   In '-eval' environment, the argument of 'if' (including '| endif')
"   is ignored. So all lines after 'if' are ignored too. But
"   backslashes of line-continuation are still recognized and
"   cause errors when 'compatible' option is set. So
"   setting 'cpoptions' to enable line-continuation before
"   'if' statement makes sure all lines get ignored without error.
" }}}
set cpoptions-=C | if 0 | endif

call my#init#setup()

call my#init#colorscheme#setup()

call my#init#commands#setup()

" SID {{{1

function! s:SID()
  return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
endfunction



" Load initial plugins {{{1

function! s:load_init_plug(name) abort
  execute 'packadd' a:name

  let docdir = $MYVIMDIR . '/pack/init/opt/' . a:name . '/doc'
  if isdirectory(docdir)
    execute 'helptags' docdir
  endif
endfunction


" Basic options {{{1

language C
set helplang =en,ja

set encoding      =utf-8
set fileencoding  =utf-8
set fileencodings =utf-8,cp932

if exists('&ambiwidth')
  set ambiwidth =double
endif

filetype plugin indent on
syntax on

" Default tab/space settings.
set tabstop     =4
set shiftwidth  =4
set softtabstop =4
set expandtab
set autoindent
set smartindent

" Search settings.
set hlsearch
set incsearch
set ignorecase
set smartcase

" Avoid highlighting the last search pattern at reloading vimrc.
nohlsearch

" Disable file backups.
set nobackup
set nowritebackup
set noswapfile

if has('persistent_undo')
  if ! isdirectory($VIMLOCAL . '/undo')
    call mkdir($VIMLOCAL . '/undo')
  endif
  set undofile
  set undodir =$VIMLOCAL/undo
endif

" Briefly jump to the matching bracket.
set showmatch
set matchtime =2
set matchpairs& matchpairs+=<:>

" Folds settings.
set foldmethod =marker
set foldcolumn =3

set cursorline
set number
set relativenumber
set hidden
set ruler
set showcmd
set showmode
set autoread
set nostartofline
set title
set wildmenu
set list
set listchars   =tab:>\ "
set backspace   =indent,eol,start
set linespace   =1
set mouse       =a
set clipboard   =unnamed
set keywordprg  =:help
set scrolloff   =3
set textwidth   =0
set history     =50
set laststatus  =2
set cmdheight   =2
set completeopt =longest,menuone
set whichwrap   =b,s,<,>,[,]
set statusline  =%f%m%r%h%w\ -\ [%{(&fenc!=''?&fenc:&enc)}\ %{&ff}\ %Y]\ [%Llines\]\ (%04l,%04v)
set formatoptions =croql
set fileignorecase
set timeoutlen  =1200
set ttimeoutlen =10 " To eliminate delays on <Esc> in terminal.
set gdefault

" Indent counts of leading backslash for line continuations in vim script.
let g:vim_indent_cont = 2



" Default events {{{1

augroup vimrc
  autocmd WinEnter * checktime
  autocmd BufReadPost * RestoreCursorPosition
augroup END



" Filetype settings {{{1

" Options for each file type {{{2

" Helper function {{{

function! s:delegate_filetypes(filetypes)
  for [name_pattern, type] in items(a:filetypes)
    execute 'autocmd BufNewFile,BufRead' name_pattern
      \ 'setlocal filetype='.type
  endfor
endfunction

function! s:reflesh_commentstring_in_html()
  let syntaxes = join(s:get_current_syntax_names(), ' ')
  if syntaxes =~ 'html'
    setlocal commentstring=<!--%s-->
  elseif syntaxes =~ 'javaScript'
    setlocal commentstring=//%s
  elseif syntaxes =~ 'css'
    setlocal commentstring=/*%s*/
  else
  endif
endfunction

" }}}

augroup vimrc
  " Groovy local settings
  autocmd FileType groovy setlocal cindent cinoptions& cinoptions+=j1

  " Show relative line numbers in help files.
  autocmd FileType help setlocal relativenumber

  " Set commentstring correctly for JS and CSS in HTML and Vue files.
  autocmd CursorMoved *.html,*.vue call <SID>reflesh_commentstring_in_html()

  autocmd FileType ocaml setlocal commentstring=(*%s*)

  " The textwidth is set as 78 by default.
  autocmd FileType vim setlocal textwidth=0

  " Configure filetypes which have to be assigned manually.
  call s:delegate_filetypes({
    \ '*.gradle'     : 'groovy',
    \ '*.es6'        : 'javascript',
    \ '.babelrc'     : 'json',
    \ '.pryrc'       : 'ruby',
    \ 'Guardfile'    : 'ruby',
    \ 'Vagrantfile'  : 'ruby',
    \ 'Berksfile'    : 'ruby',
    \ 'Dockerfile*'  : 'Dockerfile',
    \ '*.purs'       : 'haskell',
    \ '*.css'        : 'scss',
    \ })
augroup END


" Indent settings {{{2

augroup vimrc
  autocmd FileType javascript ShortIndent
  autocmd FileType typescript ShortIndent
  autocmd FileType coffee     ShortIndent
  autocmd FileType css        ShortIndent
  autocmd FileType scss       ShortIndent
  autocmd FileType sass       ShortIndent
  autocmd FileType haml       ShortIndent
  autocmd FileType yaml       ShortIndent
  autocmd FileType ruby       ShortIndent
  autocmd FileType vim        ShortIndent
  autocmd FileType vimspec    ShortIndent
  autocmd FileType scala      ShortIndent
  autocmd FileType sql        ShortIndent
  autocmd FileType json       ShortIndent
  autocmd FileType html       ShortIndent
  autocmd FileType xhtml      ShortIndent
  autocmd FileType eruby      ShortIndent
  autocmd FileType jsp        ShortIndent
  autocmd FileType vue        ShortIndent
  autocmd FileType terraform  ShortIndent
  autocmd FileType c          MediumIndent
  autocmd FileType cs         MediumIndent
  autocmd FileType vb         MediumIndent
  autocmd FileType java       MediumIndent
  autocmd FileType groovy     MediumIndent
  autocmd FileType xml        MediumIndent
  autocmd FileType sh         MediumIndent
  autocmd FileType markdown   MediumIndent
  autocmd FileType go         IndentBy 4 0
  autocmd FileType text       IndentBy 4 0
  autocmd FileType help       IndentBy 8 0
augroup END


" Apply file type settings {{{2
if ! has('vim_starting')
  " Apply file type settings to the current buffer when vimrc is reloaded.
  doautocmd vimrc FileType
endif



" Key mappings {{{1

" Set up {{{2

call s:load_init_plug('mapping.vim')

call mapping#set_sid(s:SID())
let g:mapping_named_key_format = '\[%s]'

" Change the mapping of text object {rhs} to {lhs}.
function! s:map_text_object(lhs, rhs)
  execute 'Map ox' 'i' . a:lhs  'i' . a:rhs
  execute 'Map ox' 'a' . a:lhs  'a' . a:rhs
endfunction

" Define 'mapleader' before all mappings usiing <Leader>.
let mapleader = "-"
Map nv - <Nop>

" Disable these keys to use as the main leader keys.
Map n m       <Nop>
Map n q       <Nop>
Map n <Space> <Nop>


" Numbers {{{2

" Invert numbers by <Space> (to type 6 - 9 by left hand).
for s:n in range(1, 9)
  execute 'Map nvo <Space>' . s:n . ' ' . (10 - s:n)
endfor
unlet s:n


" Insert mode {{{2

Map i <C-j> <Down>
Map i <C-k> <Up>
Map i <C-h> <Left>
Map i <C-l> <Right>
Map i <C-a> <Esc><S-i>
Map i <C-e> <End>
Remap i <C-CR> <End><CR>
Remap i <S-CR> <C-o>O
Remap i <S-Tab> <Tab><Tab>

Map i (expr) <Tab>  pumvisible() ? "\<C-n>" : "\<Tab>"

" Break undo sequence after these deletions in Insert mode.
Map i <C-w> <C-g>u<C-w>
Map i <C-u> <C-g>u<C-u>

" Break a line without inserting the comment leader.
Map i <C-]> <C-o>:set formatoptions-=ro<CR><CR><C-o>:set formatoptions+=ro<CR>

Map i <C-w> <C-r>=<SID>start_file_completion()<CR>

if !g:is_gui
  " I don't know why but `Ctrl+Space` pastes text in clipboard
  " only when I use Vim on the terminal.
  " This is annoying so just insert a space instead.
  " (ref: http://h-miyako.hatenablog.com/entry/2014/01/20/053327)
  Map i <Nul> <Space>
endif

" Improve file path completion {{{3
" Vim has a file name completion but it is done from the
" current directory, not a directory of a current file.
" But I want to do it from the current file's directory.
" To achieve this, we need to change the current directory
" temporaliry while completion.
let s:file_completion_curdir = ''
function! s:start_file_completion()
  let cwd = getcwd()
  let file_dir = expand("%:p:h")

  if empty(s:file_completion_curdir) && cwd != file_dir
    augroup vimrc_file_completion
      autocmd InsertLeave * call <SID>restore_current_dir()
    augroup END
    let s:file_completion_curdir = cwd
  endif

  call execute('cd ' . file_dir)
  return "\<C-x>\<C-f>"
endfunction

function! s:restore_current_dir()
  call execute('cd ' . s:file_completion_curdir)
  let s:file_completion_curdir = ''
  augroup vimrc_file_completion
    autocmd!
  augroup END
endfunction


" Visual mode {{{2

" Reselect visual block after indent.
Map v < <gv
Map v > >gv


" Command-line mode {{{2

" Like emacs.
Map c <C-a> <Home>
Map c <C-b> <Left>
Map c <C-e> <End>
Map c <C-f> <Right>
Map c <C-n> <Down>
Map c <C-p> <Up>

" Paste current path by '%%'.
Map c (expr) %% getcmdtype() == ':' ? expand('%:h') : '%%'


" Basic operation in normal mode {{{2

Map n mm m
Map n _  `
Map n <C-h>     :us:help
Map n <Leader>h :us:vert help
Map n <Space>w  ::update
Map n <Space>W  ::update!
Map n <Space>q  ::quit
Map n <Space>Q  ::quit!
Map n Y y$
Map n Q q
Map n <Leader>d ::pwd
Map n zp zMzv

" Break lines and Insert spaces in normal mode.
Map n <C-CR>          o<Esc>
Map n <S-CR>          O<Esc>
Map n <S-Space>       i<Space><Esc>
Map n <Leader><Space> a<Space><Esc>

" Remove trailing whitespaces.
Map n (silent) <Leader>c ::Rtw

" In US keyboard, typing ':' is so hard..
Map nv ; :
Map nv : ;

Map nvo <C-j> }
Map nvo <C-k> {


" Fix the direction of the ';', ',', 'n', 'N' {{{2

" Make the ';' key always move to the right.
" Make the ',' key always move to the left.
Map nvo (expr) f <SID>map_repeat_keys_and_move_to_occurrence(1, 'f')
Map nvo (expr) F <SID>map_repeat_keys_and_move_to_occurrence(0, 'F')
Map nvo (expr) t <SID>map_repeat_keys_and_move_to_occurrence(1, 't')
Map nvo (expr) T <SID>map_repeat_keys_and_move_to_occurrence(0, 'T')

" Make the 'n' key always move forward.
" Make the 'N' key always move backward.
Map nvo (expr) n <SID>search_pattern_to_fixed_direction('n', 'N')
Map nvo (expr) N <SID>search_pattern_to_fixed_direction('N', 'n')

function! s:map_repeat_keys_and_move_to_occurrence(direct_to_right, command)
  if a:direct_to_right
    Map nvo : ;
    Map nvo , ,
  else
    Map nvo : ,
    Map nvo , ;
  endif
  return a:command
endfunction

function! s:search_pattern_to_fixed_direction(normal_key, reverse_key)
  return v:searchforward ? a:normal_key : a:reverse_key
endfunction


" Text objects {{{2

call s:map_text_object('d', '"')
call s:map_text_object('s', "'")
call s:map_text_object('m', ')')
call s:map_text_object('n', '}')
call s:map_text_object('y', '>')


" Toggle options {{{2

MapNamedKey co toggle

" Toggle search highlight.
Map n (silent) \[toggle]h ::let v:hlsearch = ! v:hlsearch

" Toggle scrollbinds of each window.
Map n \[toggle]S ::windo setlocal scrollbind! scrollbind?

" Toggle indent width.
Map n \[toggle]i :f:<SID>toggle_indent_width()

function! s:toggle_indent_width()
  if &tabstop <= 2
    call s:set_indent(4, &expandtab)
    echo 'Medium indent (4)'
  else
    call s:set_indent(2, &expandtab)
    echo 'Short indent (2)'
  endif
endfunction

" Toggle colorschemes.
Map n \[toggle]c :f:<SID>toggle_colorschemes()

let s:togglable_colors = ['smyck256', 'hybrid']
function! s:toggle_colorschemes()
  let current = index(s:togglable_colors, g:colors_name)
  let next = (current + 1) % len(s:togglable_colors)
  execute 'colorscheme' s:togglable_colors[next]
endfunction

" Toggle comment continuation at line breaking.
Map n \[toggle]* :f:<SID>toggle_comment_continuation()

function! s:toggle_comment_continuation()
  let will_continue = ( match(&formatoptions, '\v[ro]') != -1 )
  if will_continue
    set formatoptions -=ro
    echo 'Do not continue comment lines'
  else
    set formatoptions +=ro
    echo 'Continue comment lines'
  endif
endfunction


" Disallow some delete operations to change clipboard {{{2

" The 'd' and 'c' keys can change clipboard.
for s:lkey in ['s', 'x']
  let s:ukey = toupper(s:lkey)
  execute 'Map nv' s:lkey '"_' . s:lkey
  execute 'Map nv' s:ukey '"_' . s:ukey
endfor

" Leave the default operation
" ('ms' is used by 'easymotion').
Map nv mx x
Map nv mX X

" The 'md' and 'mc' commands delete texts without copy.
Map nv md "_d
Map nv mD "_D
Map nv mc "_c
Map nv mC "_C


" Paste texts smartly {{{2

Map i (silent) <C-v> <C-o>:set paste<CR><C-r>*<C-o>:set nopaste<CR>
Map c <C-v> <C-r>*


" Grep by external programs {{{2

  MapNamedKey <Space>s grep
  Map n (expr) \[grep]s my#init#func#grep#by_current(0)
  Map n (expr) \[grep]+ my#init#func#grep#by_current(1)
  Map n \[grep]l ::ShowGreps
  Map n \[grep]a ::ChangeGrep ag
  Map n \[grep]g ::ChangeGrep git
  Map n \[grep]v ::ChangeGrep git


" Quickfix {{{2

Map n qo  ::cwindow
Map n qc  ::cclose
Map n qj  ::cnext
Map n qk  ::cprevious
Map n ql  ::cnfile
Map n qh  ::cpfile
Map n qgg ::cfirst
Map n qG  ::clast
Map n qn  ::cnewer
Map n qp  ::colder


" Buffers {{{2

MapNamedKey <Space>b buffer
Map n \[buffer]a ::buffer #
Map n \[buffer]d ::bdelete
Map n \[buffer]l ::ls
Map n \[buffer]s :us:ls<CR>:buffer
Map n \[buffer]j ::execute 'buffer' v:count1


" Tabs {{{2

" Use 't' as the prefix of tab motions.
MapNamedKey t tab
Map n \[tab]n ::tabnew
Map n \[tab]h gT
Map n \[tab]l gt
" TODO: mappings for tab motions


" Window and Terminal {{{2

" Like Tmux
set noequalalways
set splitright
set splitbelow

autocmd vimrc TerminalOpen * call s:setup_terminal_buffer()

function! s:setup_terminal_buffer() abort
  " Disable these options to keep the window width same between
  " the terminal mode and terminal-normal mode.
  setlocal nonumber
  setlocal norelativenumber
  setlocal foldcolumn=0
endfunction

" Currently we use <C-w> for 'termwinkey' and change the <C-w> to <C-t> in my shell.

Map n <C-w>- ::split
Map n <C-w>\\ ::vsplit
Map n <C-w>v ::call <SID>split_from_buf({'ratio': 0.35})
Map n <C-w>V ::call <SID>split_from_buf({'ratio': 0.35, 'vert': 1})
Map n <C-w>t- ::call <SID>split_from_buf({'term': 1})
Map n <C-w>t\\ ::call <SID>split_from_buf({'term': 1, 'vert': 1})
Map n <C-w>tv ::call <SID>split_from_buf({'term': 1, 'ratio': 0.35})
Map n <C-w>tV ::call <SID>split_from_buf({'term': 1, 'ratio': 0.35, 'vert': 1})
Map n <C-w>tt ::terminal ++curwin

Map t <C-w>- <C-\><C-n>:call <SID>split_from_term({})<CR>
Map t <C-w>\\ <C-\><C-n>:call <SID>split_from_term({'vert': 1})<CR>
Map t <C-w>t- <C-\><C-n>:call <SID>split_from_term({'term': 1})<CR>
Map t <C-w>t\\ <C-\><C-n>:call <SID>split_from_term({'term': 1, 'vert': 1})<CR>
Map t <C-w>tv <C-\><C-n>:call <SID>split_from_term({'term': 1, 'ratio': 0.35})<CR>
Map t <C-w>tV <C-\><C-n>:call <SID>split_from_term({'term': 1, 'ratio': 0.35, 'vert': 1})<CR>
Map t <C-w>n <C-\><C-n>
Map t <C-w><C-n> <C-\><C-n>

function! s:split_from_buf(opt) abort
  let src_win = win_getid()
  call s:split_by_ratio(src_win, a:opt)
endfunction

function! s:split_from_term(opt) abort
  let src_win = win_getid()
  call s:split_by_ratio(src_win, a:opt)

  " The src window is now in normal mode so restore the terminal mode.
  " Without this, we need to change the mode manually when we back to the
  " src window. This is not handy.
  let dest_win = win_getid()
  call win_gotoid(src_win)
  normal i
  call win_gotoid(dest_win)
endfunction

function! s:split_by_ratio(src_win, opt) abort
  let is_vertical = get(a:opt, 'vert', 0)
  let prefix = is_vertical ? 'vertical' : ''
  let cur_size = is_vertical ? winwidth(a:src_win) : winheight(a:src_win)

  execute prefix 'split'
  if get(a:opt, 'term', 0)
    term ++curwin
  else
    enew
  endif

  if has_key(a:opt, 'ratio')
    let desired_size = cur_size * a:opt.ratio
    execute prefix 'resize' string(desired_size)
  endif
endfunction



" Plugins {{{1

" Loading plugins asynchronously redraws a screen soon
" so suppress the welcome message which disappears by the redrawing.
set shortmess=I

call s:load_init_plug('vim-plugger')

if !$VIM_NO_PLUG
  call plugger#enable({
    \   'conf_root': $MYVIMDIR . '/autoload/my/plug/',
    \   'autoload_prefix': 'my#plug#',
    \ })
endif

runtime macros/matchit.vim



" Local settings {{{1

if filereadable($VIMLOCAL . '/vimrc')
  source $VIMLOCAL/vimrc
  command! Evl edit $VIMLOCAL/vimrc
endif

" }}}

" vim: expandtab softtabstop=2 shiftwidth=2 foldmethod=marker
